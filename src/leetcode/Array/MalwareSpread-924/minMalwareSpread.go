package MalwareSpread_924

import "math"

type UnionFind struct {
	parent []int
	size   []int
}

func (uf *UnionFind) Init(n int) {
	uf.parent = make([]int, n)
	uf.size = make([]int, n)
	for i := range uf.parent {
		uf.parent[i] = i
		uf.size[i] = 1
	}
}

func (uf *UnionFind) Find(x int) int {
	if uf.parent[x] != x {
		uf.parent[x] = uf.Find(uf.parent[x])
	}
	return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) {
	rootX, rootY := uf.Find(x), uf.Find(y)
	if rootX != rootY {
		uf.parent[rootX] = rootY
		uf.size[rootY] += uf.size[rootX]
	}
}

func minMalwareSpread(graph [][]int, initial []int) int {
	if len(initial) == 0 {
		return 0
	}

	uf := UnionFind{}
	uf.Init(len(graph))

	for i := range graph {
		for j := i + 1; j < len(graph); j++ {
			if graph[i][j] == 1 {
				uf.Union(i, j)
			}
		}
	}

	compMap := make(map[int][]int)
	for _, i := range initial {
		compMap[uf.Find(i)] = append(compMap[uf.Find(i)], i)
	}

	uniqInitials := make(map[int]int)
	for _, v := range compMap {
		if len(v) == 1 {
			uniqInitials[v[0]] = v[0]
		}
	}

	if len(uniqInitials) == 0 {
		smallestIdx := initial[0]
		for _, i := range initial {
			if i < smallestIdx {
				smallestIdx = i
			}
		}
		return smallestIdx
	}

	maxLen, maxIdx := math.MinInt32, -1
	for _, i := range initial {
		if _, ok := uniqInitials[i]; ok {
			size := uf.size[uf.Find(i)]
			if maxLen < size || (maxLen == size && i < maxIdx) {
				maxLen, maxIdx = size, i
			}
		}
	}

	return maxIdx
}
